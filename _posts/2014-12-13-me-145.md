---
layout: post
title: "Robotic Planning and Kinematics"
description: "ME 145- Robotic Planning and Kinematics"
modified: 2016-10-07
tags: [Mechanical Engineering, project]
categories: [Mechanical Engineering]
image:
  background: grey_wash_wall.png
  feature: /ME145/robotics_cover2.jpg
---
<style>
hr{
	border: 0;
    height: 1px;
    background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
}
</style>

## 1. Sensor-Based Motion Planning
Motion planning is an important and common problem in robotics. In its simplest form, the motion planning problem is: how to move a robot from a "start" location to a "goal" locaion avoiding obstacles.

### Robot Assumptions
* knows the direction towards the goal,
* knows the straight-line distance between itself and the goal,
* does not knwo anything about the obstacles (number, location, shape, etc.)
* has a contact sensor that allows it to locally detect obstacles,
* can move either in a straight line towards the goal or can follow an obstacle boundary (possibly by using its contact sensor), and
* has limited memory in which it can store distances and angles.

### Environment Assumptions
* the workspace is bounded
* there are only a finite number of obstacles
* the start and goal points are in the free workspace
* any straight line drawn in the environment crosses the boundary of each obstacle only a finite number of times. (This assumption is easily satisfied for "normal objects".)

<u>Compute Line Through Two Points</u><br/>
**Input:** two distinct points P1 = (x1,y1) and P2 = (x2,y2) on the plane <br/>
**Output:** parameters (a,b,c) defining the line {(x,y)|ax+by+c = 0} that passes through both P1 and P2.
Normalize the parameters so that a^2+b^2 = 1.

<cite>Using Matlab</cite>

>>function [a,b,c] = line_points(p1,p2) <br/>
A = [p1(1,1) p2(1,1)]; <br/>
B = [p1(1,2) p2(1,2)]; <br/>
if (p1(1,1) == p2(1,1)) <br/>
&nbsp;&nbsp;&nbsp;a = 1; <br/>
&nbsp;&nbsp;&nbsp;b = 0; <br/>
&nbsp;&nbsp;&nbsp;c = -p1(1,1); <br/>
else <br/>
&nbsp;&nbsp;&nbsp;p = polyfit(A,B,1); <br/>
&nbsp;&nbsp;&nbsp;slope = p(1,1); <br/>
&nbsp;&nbsp;&nbsp;intercept = p(1,2); <br/>
&nbsp;&nbsp;&nbsp;a = slope/sqrt(slope^2+1); <br/>
&nbsp;&nbsp;&nbsp;b = -sqrt(1-a^2); <br/>
&nbsp;&nbsp;&nbsp;c = intercept•-b; <br/>
&nbsp;&nbsp;&nbsp;if c < 10^-10 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = 0; <br/>
&nbsp;&nbsp;&nbsp;end <br/>
end <br/>
disp(['ax+by+c=0']) <br/>
end

<u>Compute Distance Point To Line</u><br/>
**Input:** a point q and two distinct points P1 = (x1, y1) and P2 = (X2, Y2) defining a line. <br/>
**Output:** the distance from q to the line defined by P1 and P2.

<cite>Using Matlab</cite>

>>function [distance] = d_pl(p1,p2,Q) <br/>
%P1,P2,Q are written as [x,y] format <br/>
A = [p1(1,1) p1(1,2) 0]; <br/>
B = [p1(1,1) p2(1,2) 0]; <br/>
Q = [Q(1,1) Q(1,2) 0]; <br/>
AB = A-B; <br/>
BQ = Q-B; <br/>
ABBQ = cross(AB,BQ); <br/>
distance = norm(ABBQ)/norm(AB); <br/>
end

<u>Compute Distance Point To Segment</u> <br/>
**Input:** a point q and a segment defined by two distinct points (P1, P2). <br/>
**Output:** the distance from q to the segment with extreme points (P1, P2).

<cite>Using Matlab</cite>

>>function [distance] = d_ps(p1,p2,Q) <br/>
%P1,P2,Q are written as [x,y] format <br/>
A = [p1(1,1) p1(1,2)]; <br/>
B = [p2(1,1) p2(1,2)]; <br/>
Q = [Q(1,1) Q(1,2)]; <br/>
AB = norm(A-B); <br/>
AQ = norm(A-Q); <br/>
BQ = norm(B-Q); <br/>
if dot(A-B,Q-B)•dot(Q-A,Q-A) >= 0 <br/>
&nbsp;&nbsp;&nbsp;x = [A,1;B,1;Q,1]; <br/>
&nbsp;&nbsp;&nbsp;distance = abs(det(x))/AB; <br/>
else <br/>
&nbsp;&nbsp;&nbsp;distance = min(AQ,BQ); <br/>
end <br/>
end

<u>Compute Distance Point To Polygon</u> <br/>
**Input:** a polygon P and a point q. <br/>
**Output:** the distance from q to the closest point in P, called the distance from q to the polygon.

<cite>Using Matlab</cite>

>>function [distance] = d_pp(P,Q) <br/>
%P is written as [x1,y1;x2,y2;...] format and Q is written as [x,y] format <br/>
n = length(P); <br/>
i = 1; <br/>
d = []; <br/>
while i < n <br/>
&nbsp;&nbsp;&nbsp;A = [P(i,1) P(i,2)]; <br/>
&nbsp;&nbsp;&nbsp;B = [P(i+1,1) P(i+1,2)]; <br/>
&nbsp;&nbsp;&nbsp;Q = [Q(1,1) Q(1,2)]; <br/>
&nbsp;&nbsp;&nbsp;AB = norm(A-B); <br/>
&nbsp;&nbsp;&nbsp;AQ = norm(A-Q); <br/>
&nbsp;&nbsp;&nbsp;BQ = norm(B-Q); <br/>
&nbsp;&nbsp;&nbsp;if dot(A-B,Q-B)•dot(B-A,Q-A) >= 0 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X = [A,1;B,1;Q,1]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = sym(X); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distacne = abs(det(x))/AB; <br/>
&nbsp;&nbsp;&nbsp;else <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance = min(AQ,BQ); <br/>
&nbsp;&nbsp;&nbsp;end <br/>
&nbsp;&nbsp;&nbsp;d(1,i) = distance; <br/>
&nbsp;&nbsp;&nbsp;i = i+1: <br/>
end <br/>
A = [P(1,1) P(1,2)]; <br/>
B = [P(n,1) P(n,2)]; <br/>
Q = [Q(1,1) Q(1,2)]; <br/>
AB = norm(A-B); <br/>
AQ = norm(A-Q); <br/>
BQ = norm(B-Q); <br/>
if dot(A-B,Q-B)•dot(B-A,Q-A) >= 0 <br/>
&nbsp;&nbsp;&nbsp;X = [A,1;B,1;Q,1]; <br/>
&nbsp;&nbsp;&nbsp;x = sym(X); <br/>
&nbsp;&nbsp;&nbsp;distance = abs(det(x))/AB; <br/>
else <br/>
&nbsp;&nbsp;&nbsp;distance = min(AQ,BQ); <br/>
end <br/>
d(1,n) = distance; <br/>
distance = min(d); <br/>
end

<u>Compute tangent Vector To polygon</u> <br/>
**Input:** a polygon P and a point q. <br/>
**Output:** the unit-length vector u tangent at point q to the polygon P in the following sense: (i) if q is closest to a segment of the polygon, then u should be parallel to the segment, (ii) if q is closest to a vertex, then u should be tangent to a circle centered at the vertex that passes through q, and (iii) the tangent should lie in the counter-clockwise direction. 

<cite>Using Matlab</cite>

>>function [u] = v_pp(P,Q) <br/>
n = length(P); <br/>
i = 1; <br/>
d = []; <br/>
%Finding shortest dist from 1->n <br/>
while i < n <br/>
&nbsp;&nbsp;&nbsp;A = [P(i,1) P(i,2)]; <br/>
&nbsp;&nbsp;&nbsp;B = [P(i+1,1) P(i+1,2)]; <br/>
&nbsp;&nbsp;&nbsp;Q = [Q(1,1) Q(1,2)]; <br/>
&nbsp;&nbsp;&nbsp;AB = norm(A-B); <br/>
&nbsp;&nbsp;&nbsp;AQ = norm(A-Q); <br/>
&nbsp;&nbsp;&nbsp;BQ = norm(B-Q); <br/>
&nbsp;&nbsp;&nbsp;if dot(A-B,Q-B)•dot(B-A,Q-A) >= 0 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X = [A,1;B,1;Q,1]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = sym(X); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance - abs(det(x))/AB; <br/>
&nbsp;&nbsp;&nbsp;else <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance = min(AQ,BQ); <br/>
&nbsp;&nbsp;&nbsp;end <br/>
&nbsp;&nbsp;&nbsp;d(1,i) = distance; <br/>
&nbsp;&nbsp;&nbsp;i = i+1; <br/>
end <br/>
%Find dist from n->1 <br/>
A = [P(1,1) P(1,2)]; <br/>
B = [P(n,1) P(n,2)]; <br/>
Q = [Q(1,1) Q(1,2)]; <br/>
AB = norm(A-B); <br/>
AQ = norm(A-Q); <br/>
BQ = norm(B-Q); <br/>
if dot(A-B,Q-B)•dot(B-A,Q-A) >= 0 <br/>
&nbsp;&nbsp;&nbsp;X = [A,1;B,1;Q,1]; <br/>
&nbsp;&nbsp;&nbsp;x = sym(X); <br/>
&nbsp;&nbsp;&nbsp;distance = abs(det(x))/AB; <br/>
else <br/>
&nbsp;&nbsp;&nbsp;distance = min(AQ,BQ); <br/>
end <br/>
d(1,n) = distance; <br/>
distance = min(d); <br/>
f = find(ismember(d,distance),1); <br/>
if f == n; <br/>
&nbsp;&nbsp;&nbsp;g = 1; <br/>
else <br/>
&nbsp;&nbsp;&nbsp;g = f+1; <br/>
end <br/>
x1 = P(f,1)-Q(1,1); <br/>
y1 = P(f,2)-Q(1,2); <br/>
x2 = P(g,1)-Q(1,1); <br/>
y2 = P(g,2)-Q(1,2); <br/>
c1 = sqrt(x1^2+y1^2); <br/>
c2 = sqrt(x2^2+y2^2); <br/>
l1 = sqrt((P(f,1)-P(g,1))^2+(P(f,2)-P(g,2))^2); <br/>
if distance ~= c1 & distance ~= c2; <br/>
&nbsp;&nbsp;&nbsp;l2 = sqrt(c2^2-distance^2); <br/>
&nbsp;&nbsp;&nbsp;xcenter = l2/l1•(x1-x2); <br/>
&nbsp;&nbsp;&nbsp;ycenter = l2/l1•(y1-y2); <br/>
&nbsp;&nbsp;&nbsp;center = [P(g,1)+xcenter,P(g,2)+ycenter]; <br/>
&nbsp;&nbsp;&nbsp;x3 = center(1,1)-Q(1,1); <br/>
&nbsp;&nbsp;&nbsp;y3 = center(1,2)-Q(1,2); <br/>
&nbsp;&nbsp;&nbsp;u = [y3,-x3]; <br/>
&nbsp;&nbsp;&nbsp;u = u/distance; <br/>
elseif c1 < c2 <br/>
&nbsp;&nbsp;&nbsp;u = [y1,-x1]; <br/>
&nbsp;&nbsp;&nbsp;u = u/distance; <br/>
elseif c2 < c1 <br/>
&nbsp;&nbsp;&nbsp;u = [y2,-x2]; <br/>
&nbsp;&nbsp;&nbsp;u = u/distance; <br/>
end <br/>
%Check if length = 1 <br/>
%u(1,1)^2+u(1,2)^2 <br/>
end

### The Bug0 Algorithm

>>1. **while** not at goal: <br/>
2. &nbsp;&nbsp;&nbsp;move towards the goal <br/>
3. &nbsp;&nbsp;&nbsp;**if** hit an obstacle: <br/>
4. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**while** not able to move towards the goal: <br/>
5. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;follow the obstacle's boundary <cite>moving to the left</cite>

Unfortunately, Bug0 algorithm does not work properly in the sense that there are situations (workspace, obstacles, start and goal positions) for which there exists a solution (a path from start to goal) but the Bug0 algorithm does not find it.

### The Bug1 Algorithm

>>1. **while** not at goal: <br/>
2. &nbsp;&nbsp;&nbsp;move towards the goal <br/>
3. &nbsp;&nbsp;&nbsp;**if** hit an obstacle: <br/>
4. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;circumnavigate it(moving to the left or right is unimportant). While circumnavigating, store in memory the minimum distance from the obstacle boundary to the goal <br/>
5. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;follow the boundary back to the boundary point with minimum distance to the goal

### Flowcharts

* Circles represent the start and terminating points
* Arrows indicate the flow of control
* Rectangles represent a single command
* Diamonds output 2 paths based on binary question

<u>Sketch a flowchart and implement the BugBase algorithm.</u> <br/>
**The BugBase Algorithm** <br/>
**Input:** Two locations start and goal in W, a list of polygon obstacles obstaclesList, and a length step-size l. <br/>
**Output:** A sequence, denoted path, of points from start to the first obstacle between start and goal (or from start to goal if no obstacle lies between them). Successive points are separated by no more than step-size.

>>1. current-position = start <br/>
2. path = [start] <br/>
3. **while** distance(current-position,goal) > step-size: <br/>
4. &nbsp;&nbsp;&nbsp;find polygon closest to current-position <br/>
5. &nbsp;&nbsp;&nbsp;**if** distance from current-position to closest polygon < step-size: <br/>
6. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**return** "Failure: There is an obstacle lying between the start and goal" and path <br/>
7. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compute new current-position by taking a step of length step-size towards goal <br/>
8. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path = [path,current-position] <br/>
9. path = [path,goal] <br/>
10. **return** "Success" and path

<img src="/images/ME145/flowchart.jpg">

<u>Compute Bug1</u> <br/>
**Input:** Two locations start and goal in W, a list of polygonal obstacles obstacleList, and a length step-size <br/>
**Output:** A sequence, denoted path, of points from start to goal or returns an error message if such a path does not exists.  Successive points are separated by no more than step-size and are computed according to the Bug 1 algorithm.

<cite>Using Matlab</cite>

>>fucntion [path] = Bug_One(S,G,O,Step) <br/>
%S = starting point, G = goal point, O = obstacles, Step = Step Size <br/>
t = 0; <br/>
%Check if solvable or not <br/>
i = 1; <br/>
l = length (O); <br/>
start = []; <br/>
goal = []; <br/>
while i < l; <br/>
&nbsp;&nbsp;&nbsp;[st] = inpolygon(S(1,1),S(1,2),(O{1,i}(:,1)),(O{1,i}(:,2))); <br/>
&nbsp;&nbsp;&nbsp;[go] = inpolygon(G(1,1),G(1,2),(O{1,i}(:,1)),(O{1,i}(:,2))); <br/>
&nbsp;&nbsp;&nbsp;i = i+1; <br/>
&nbsp;&nbsp;&nbsp;start = [start,st]; <br/>
&nbsp;&nbsp;&nbsp;goal = [goal,go]; <br/>
end <br/>
if sum(start) > 0; <br/>
&nbsp;&nbsp;&nbsp;disp('Failure: Start Point in Polygon'); <br/>
&nbsp;&nbsp;&nbsp;path = Nan; <br/>
&nbsp;&nbsp;&nbsp;return; <br/>
elseif sum(goal) > 0; <br/>
&nbsp;&nbsp;&nbsp;disp('Failure: Goal Point in Polygon'); <br/>
&nbsp;&nbsp;&nbsp;path = Nan; <br/>
&nbsp;&nbsp;&nbsp;return; <br/>
else <br/>
&nbsp;&nbsp;&nbsp;%Implement Bug 1 Algorithm <br/>
&nbsp;&nbsp;&nbsp;current = S; <br/>
&nbsp;&nbsp;&nbsp;path = [S]; <br/>
&nbsp;&nbsp;&nbsp;total = []; <br/>
&nbsp;&nbsp;&nbsp;while norm(G-current) > Step; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%Find the Closest polygon to S <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = 1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sclosest = []; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while j <= l; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P = O{i,j}; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q = S; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[distance] = d_pp(P,Q); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sclosest = [Sclosest,distance];&nbsp;&nbsp;%Matrix dist S to Polygons <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = j+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%Find the Closest Polygon toG <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jj = 1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gclosest = []; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while jj <=l; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P = O{1,jj}; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q = G; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[distance = d_pp(P,Q)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gclosest = [Gclosest, distance];&nbsp;&nbsp;%Matrix dist G to polygons <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jj = jj+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while sum(Sclosest) < 200; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%Getting Phit <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = min(Sclosest); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[row,col] = find(Sclosest = temp); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spot = col; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = 1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Oalt = [O{1,spot}; O{1,spot}(1,:)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xbox = []; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ybox = []; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while k <= (length(Oalt)); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xbox = [xbox,Oalt(k,1)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ybox = [ybox,Oalt(k,2)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = k+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[xi,yi] = polyxpoly([current(1,1) G(1,1)],[current(1,2) G(1,2)], xbox, ybox); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Phit = [xi(1,1) yi(1,1)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path = [path; Phit]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total = [total, norm(Phit-current)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current = Phit; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%Getting Pleave <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = ((Oalt(1,2)-Oalt(3,2))•(G(1,1)-Oalt(3,1))-(Oalt(1,1)-Oalt(3,1))•(G(1,2)-Oalt(3,2))/((Oalt(1,2)-Oalt(3,2))^2+(Oalt(1,1)-Oalt(3,1))^2); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x4 = G(1,1)-k•(Oalt(1,2)-Oalt(3,2)); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y4 = G(1,2)+k•(Oalt(1,1)-Oalt(3,1)); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pleave = [x4,y4]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%Going around Polygon <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r= 1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z = O{1,spot}; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z = sortrows(Z,2); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while r <= length(O{1,spot}); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path = [path,Z(r,:)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total = [total,norm(Z(r,:)-current)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current = Z(r,:); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = r+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path = [path; Phit]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total = [total, norm(Phit-current)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current = Phit; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = 1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z = [Z;Pleave]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z = sortrows(Z,2); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while r < length(Z); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path = [path;Z(r,:)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total = [total,norm(Z(r,:)-current)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current = Z(r,:); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = r+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sclosest(1,spot) = 101; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gclosest(1,spot) = 0; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t+1; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total = [total,norm(G-current)]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path = [path;G]; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current = G; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total = sum(total); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t+1; <br/>
&nbsp;&nbsp;&nbsp;end <br/>
end <br/>
hold on <br/>
%axis ([0 10 0 10]) <br/>
plot(path(:,1),path(:,2)) <br/>
end

<u>Testing Bug1 Algorithm:</u> <br/>
start = (0,0) and goal = (5,3) <br/>
step-size = 0.1 obstacleList = {(1,2),(1,0),(3,0)}, {(2,3),(4,1),(5,2)}

<img src="/images/ME145/Bug1Test.jpg">

**Path:** (0,0)->(1,0.6)->(1,0)->(3,0)->(1,2)->(1,0.6)->(1,0)->(3,0)->(2.5,0.5)->(3.5,1.5)->(4,1)->(5,2)->(2,3)->(3.5,1.5)->(4,1)->(5,2)->(4.7,2.1)->(5,3) <br/>

**Total Path Length:** 23.5071 <br/>

**Time:** 21

<hr>

## 2. Motion Planning via Decomposition and Search

### Robot Assumptions
* knows the start and goal locations, and 
* knows the workspace and obstacles

### World Assumptions
* the workspace is a bounded polygon
* there are only a finite number of obstacles that are polygons inside the workspace, and
* the start and goal points are inside the workspace and outside all obstacles

The amount of time it takes for a motion planning algorithm to run, call it's <cite>run-time</cite> rather than the length of the path it produces.  The run-time of an algorithm is given by the number of computer steps required to execute the code.

### Decomposition into convex subsets
1. the <cite>triangulation</cite> of the polygon is the decomposition of the polygon into a collection of triangles, and
2. the <cite>trapizoidation</cite> of the polygon is the decomposition of the polygon into a collective of trapezoids

### The Sweeping Trapezoidation Algorithm
**Input:**  a polygon possibly with polygonal holes <br/>
**Output:** a set of disjoint trapezoids, whose union equals the polygon <br/>

>> 1. initialize an empty list T of trapezoids <br/>
2. order all vertices (of the obstacles and of the workspace) horizontally from left to right <br/>
3. **for** each vertex selected in a left-to-right sweeping order: <br/>
4. &nbsp;&nbsp;&nbsp;extend vertical segments upward and downwards from the vertex until they intersect an obstacle or the workspace boundary <br/>
5. &nbsp;&nbsp;&nbsp;add to T the new trapezoids, if any, generated by these segment(s)

Three key ideas we covered so far: <br/>
(1) convexity leads to very simple paths, (2) if the free workspace is not convex, it is easy to navigate between neighboring convex sets, (3) a complex free workspace can be decomposed into convex subsets via, for example, the sweeping trapezoidation algorithm. <br/>
The next observation is that the sweeping trapezoidation algorithm can easily be modified to additionally provide a list of neighborhood relationships between trapezoids.

### The Roadmap-from-Decomposition Algorithm
**Input:** the trapezoidation of a polygon (possibly with holes) <br/>
**Output:** a roadmap

>> 1. label the center of each trapezoid with the symbol &#9826; <br/>
2. label the midpoint of each vertical separating segment with the symbol &diams; <br/>
3. **for** each trapezoid: <br/>
4. &nbsp;&nbsp;&nbsp;connect the center to all the midpoints in the trapezoid <br/>
5. **return** the roadmap consisting of centers, midpoints and their connections

### The Planning-via-Decomposition + Search Algorithm
**Input:** free workspace W<sub>free</sub>, start point p<sub>start</sub> and goal point p<sub>goal</sub> <br/>
**Output:** a path from p<sub>start</sub> to p<sub>goal</sub> if it exists, otherwise a failure notice. Either outcome is obtained in finite time.

>> 1. compute a decomposition of W<sub>free</sub> and the corresponding roadmap <br/>
2. in the decomposition, find the start trapezoid containing p<sub>start</sub> and the goal trapezoid containing p<sub>goal</sub> <br/>
3. in the roadmap, search for a path from start trapezoid to goal trapezoid <br/>
4. **if** no path exists from start trapezoid to goal trapezoid <br/>
5. &nbsp;&nbsp;&nbsp;**return** failure notice <br/>
6. **else** <br/>
7. **return** path by concatenating: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the segment from p<sub>start</sub> to the center of start trapezoid <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the path from the start trapezoid to goal trapezoid <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the segment from the center of goal trapezoid to p<sub>goal</sub>

The breadth-first search algorithm, also called BFS algorithm, is one of the simplest graph search strategy and is optimal in the sense that it computes shortest paths.

### The breadth-first search (BFS) algorithm
**Input:** a graph G, a start node v<sub>start</sub> and goal node v<sub>goal</sub> <br/>
**Output:** a path from v<sub>start</sub> to v<sub>goal</sub> if it exists, otherwise a failure notice

>> 1. create an empty queue Q and insert (Q,v<sub>start</sub>) <br/>
2. **for** each node v in G: <br/>
3. &nbsp;&nbsp;&nbsp;parent(v) = NONE <br/>
4. parent(v<sub>start</sub>) = SELF <br/>
5. **while** Q is not empty: <br/>
6. &nbsp;&nbsp;&nbsp;v = retrieve(Q) <br/>
7. &nbsp;&nbsp;&nbsp;**for** each node u connected to v by an edge: <br/>
8. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**if** parent(u) == NONE: <br/>
9. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set parent(u) = v and insert (Q,u) <br/>
10. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**if** u == v<sub>goal</sub>: <br/>
11. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run extract-path algorithm to compute the path from start to goal <br/>
12. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**return** success and the path from start to goal <br/>
13. **return** failure notice along with the parent pointers

### The extract-path algorithm
**Input:** a goal node v<sub>goal</sub>, and the parent pointers <br/>
**Output:** a path from v<sub>start</sub> to v<sub>goal</sub>

>> 1. create an array P = [v<sub>goal</sub>] <br/>
2. set u = v<sub>goal</sub> <br/>
3. **while** parent(u) &#8800; SELF: <br/>
4. &nbsp;&nbsp;&nbsp;u = parent(u) <br/>
5. &nbsp;&nbsp;&nbsp;insert u at the beginning of P <br/>
6. **return** P

## 3. Configuration Spaces
1. describe a robot as a single or multiple interconnected rigid bodies,
2. define the configuration space of a robot,
3. examine numerous example configuration spaces,
4. discuss forward and inverse kinematic maps

##### Example Systems:
* <cite>Disk robo</cite>- has the shape of a disk and is characterized by just one parameter, its radius r > 0.  The disk robot does not have an orientation.  Accordingly, the disk robots only motion is translation in the plane: that is, translations in the horizontal and vertical directions.
* <cite>Translating polygon robot</cite>- has a polygonal shape.  This robot is assumed to have a fixed orientation, and thus it's only motion is translations in the plane.
* <cite>Roto-translation polygon robot</cite>- has an arbitrary polygonal shape, is capable of translating in the horizontal and vertical directions as well as rotating.
* <cite>Multi-link or multi-body robot</cite>- composed of multiple rigid bodies (or links) interconnected. Each link of the robot can rotate and translate in the plane, but these motions are constrained by connections to the other links and to the robot base.

### Configuration Space
1. A <cite>configuration</cite> of a robot is a minimal set of variables that specifies the position and orientation of each rigid body composing the robot.  The robot configuration is usually denoted bye the letter <cite>q</cite>
2. The <cite>configuration space</cite> is the set of all possible configurations of a robot. The robot configuration space is usually denoted by the letter <cite>Q</cite>, so that q &isin; Q.
3. The number of <cite>degrees of freedom</cite> of a robot is the dimension of the configuration space, i.e., the minimum number of variables required to fully specify the position and orientation of each rigid body belonging to the robot.
4. Given that the robot is at configuration q, we know where all points of the robot are.

<!-- Put Lab 3 Code Here -->

## 4. Free Configuration Spaces via Sampling and Collision Detection
1. represent obstacles and the free space when the robot is composed of a single or multiple rigid bodies with proper shape, position and orientation
2. compute free configuration spaces via sampling and collision detection,
3. discuss sampling methods
4. discuss collision detection methods

##### Free configuration space for the disk robot
To compute the <cite>free configuration space</cite> and the <cite>obstacles in configuration space</cite> we reson as follows: a disk with radius r in collision with an obstacle if and only if the disk center is closer to the obstacle than r.  Accordingly, we grow or "expand" the obstacle and, correspondingly, to "shrink" the workspace.
Using this key idea, the <cite>obstacle in configuration spce</cite> is the expanded rectangle and the <cite>fre configuration space</cite> of the disk robot is described in any of the two completely equivalent forms:
1. the set of poitns of the disk center such that the disk does not intersect the obstacle and is inside the workspace,
2. the shrunk workspace minus the expanded obstacle.

##### Free configuration space for the translating polygonal robot
There is a simple graphical approach to computing the configuration space obstacle:
1. move the robot to touch the obstacle boundary (recall the robot is not allowed to rotate),
2. slide the robot body along the obstacle boundary, maintaining the contact between the robot boundary and the obstacle boundary,
3. while sliding, store the location of the reference point of the robot: the resulting path encloses a convex polygon equal to the configuration space obstacle.

### Sampling Methods
A sampling method should have certain properties:
1. <cite>Uniformity:</cite> the samples should provide a "good covering" of space. Mathematically, this can be formulated using the notion of dispersion
2. <cite>Incremental property:</cite> the sequence of samples should provide good coverage at any number n of samples. In other words, it should be possible to increase n continuously and not only in discrete large amounts.
3. <cite>Lattice structure:</cite> given a sample, the location of nearby samples should be computationally easy to determine.

**Uniform grids** There are two ways of defining uniform grids in the unit cube.  We call them the <cite>center grid</cite> and the <cite>corner grid</cite>. Both grids with <cite>n</cite> points can be defined if n = k^d for some number <cite>k</cite>.

**Random and pseudo-random sampling** Adopting a random number generator is usually a very simple approach to (uniformly or possibly non-uniformly) sample the cube.  Randomly-sampled points have asymptotically worse dispersion than center grids.

Halton sequences are an elegant way of sampling an interval with good uniformity (better than a pseudorandom sequence, though not as good as the optimal center grid) and with the incremental property (which the center grid does not posses).

### The Halton sequence algorithm
**Input:** length of the sequence N &isin; N and prime number p &isin; N
**Output:** an array S[1...N] with the first N samples of the Halton sequence generated by p

>> 1. initialize: S to be an array of N zeros
2. **for** each i from 1 to N:
3. &nbsp;&nbsp;&nbsp;initialize: i<sub>tmp</sub> = i, and f = 1/p
4. &nbsp;&nbsp;&nbsp;**while** i<sub>tmp</sub> > 0:
5. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compute the quotient q and the remainder r of the division i<sub>tmp</sub>/p
6. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S(i) = S(i)+f•r
7. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i<sub>tmp</sub> = q
8. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = f/p
9. **return** S

### Collision detection methods
The next step is to detect whether or not these configurations are in collision with an obstacle or workspace boundary. To do this we require several collision detection methods.

##### Basic primitive #1: is a point in a convex polygon?
Given a convex polygon with counter-clockwise vertices and a point q, the following conditions are equivalent:
1. the point q is in the polygon (possibly on the boundary)
2. for all i &isin; {1,...,n}, the point q belongs to the halfplane with boundary line passing through the vertices p<sub>i</sub> and p<sub>i+1</sub> and containing the polygon
3. for all i &isin; {i,...,n}, the dot product between the interior normal to the side p<sub>i</sub>p<sub>i+1</sub> and the segment p<sub>i</sub>q is positive or zero.
(Here the convention is that p<sub>i+1</sub> = p<sub>1</sub>.  A similar set of results can be given to check that the point is strictly inside the polygon.)

##### Basic primitive #2: do two segments intersect?
Any two lines in the plane are in one of three exclusive configuration: (1) parallel and coincident, (2) parallel and distinct, or (3) intersecting at a single point. In order for two segments to intersect, the two corresponding lines may be coincident (and the two segmetns need to intersect at least partly) or may intersect at a point (and the point must belong to the two segments). Now, if the two lines intersect at a point, one still needs to check that the intersection point actually belongs to the segment.

##### Basic primitive #3: do two convex polygons intersect?
### The convex-polygon-intersection algorithm
**Input:** two convex polygons P<sub>1</sub> and P<sub>2</sub>
**Output:** collision or no collision

>> 1. **if** (any vertex of P<sub>1</sub> belongs to P<sub>2</sub>) OR (any vertex of P<sub>2</sub> belongs to P<sub>1</sub>):
2. &nbsp;&nbsp;&nbsp;**return** collision
3. **if** any edge of P<sub>1</sub> intersects any edge of P<sub>2</sub>:
4. &nbsp;&nbsp;&nbsp;**return** collision
5. **return** no collision

