---
layout: post
title: "Robotic Planning and Kinematics"
description: "ME 145- Robotic Planning and Kinematics"
modified: 2016-10-07
tags: [Mechanical Engineering, project]
categories: [Mechanical Engineering]
image:
  background: grey_wash_wall.png
  feature: /ME145/robotics_cover2.jpg
---
<style>
hr{
	border: 0;
    height: 1px;
    background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
}
</style>

## Sensor-Based Motion Planning
Motion planning is an important and common problem in robotics. In its simplest form, the motion planning problem is: how to move a robot from a "start" location to a "goal" locaion avoiding obstacles.

### Robot Assumptions
* knows the direction towards the goal,
* knows the straight-line distance between itself and the goal,
* does not knwo anything about the obstacles (number, location, shape, etc.)
* has a contact sensor that allows it to locally detect obstacles,
* can move either in a straight line towards the goal or can follow an obstacle boundary (possibly by using its contact sensor), and
* has limited memory in which it can store distances and angles.

### Environment Assumptions
* the workspace is bounded
* there are only a finite number of obstacles
* the start and goal points are in the free workspace
* any straight line drawn in the environment crosses the boundary of each obstacle only a finite number of times. (This assumption is easily satisfied for "normal objects".)

<u>Compute Line Through Two Points</u><br/>
Input: two distinct points P1 = (x1,y1) and P2 = (x2,y2)on the plane<br/>
Output: parameters (a,b,c) defining the line {(x,y)|ax+by+c = 0} that passes through both P1 and P2.
Normalize the parameters so that a^2+b^2 = 1.

<cite>Using Matlab</cite>

>>function [a,b,c] = line_points(p1,p2)
A = [p1(1,1) p2(1,1)];
B = [p1(1,2) p2(1,2)];
if (p1(1,1) == p2(1,1))
&nbsp;&nbsp;a = 1;
&nbsp;&nbsp;b = 0;
&nbsp;&nbsp;c = -p1(1,1);
else
&nbsp;&nbsp;p = polyfit(A,B,1);
&nbsp;&nbsp;slope = p(1,1);
&nbsp;&nbsp;intercept = p(1,2);
&nbsp;&nbsp;a = slope/sqrt(slope^2+1);
&nbsp;&nbsp;b = -sqrt(1-a^2);
&nbsp;&nbsp;c = intercept*-b;
&nbsp;&nbsp;if c < 10^-10
&nbsp;&nbsp;&nbsp;&nbsp;c = 0;
&nbsp;&nbsp;end
end
disp(['ax+by+c=0'])
end

<u>Compute Distance Point To Line</u><br/>
Input: a point q and two distinct points P1 = (x1, y1) and P2 = (X2, Y2) defining a line.<br/>
Output: the distance from q to the line defined by P1 and P2.

<cite>Using Matlab</cite>

>>function [distance] = d_pl(p1,p2,Q)
%P1,P2,Q are written as [x,y] format
A = [p1(1,1) p1(1,2) 0];
B = [p1(1,1) p2(1,2) 0];
Q = [Q(1,1) Q(1,2) 0];
AB = A-B;
BQ = Q-B;
ABBQ = cross(AB,BQ);
distance = norm(ABBQ)/norm(AB);
end

<u>Compute Distance Point To Segment</u><br/>
Input: a point q and a segment defined by two distinct points (P1, P2).
Output: the distance from q to the segment with extreme points (P1, P2).

<cite>Using Matlab</cite>

>>function [distance] = d_ps(p1,p2,Q)
%P1,P2,Q are written as [x,y] format
A = [p1(1,1) p1(1,2)];
B = [p2(1,1) p2(1,2)];
Q = [Q(1,1) Q(1,2)];
AB = norm(A-B);
AQ = norm(A-Q);
BQ = norm(B-Q);
if dot(A-B,Q-B)*dot(Q-A,Q-A) >= 0
&nbsp;&nbsp;x = [A,1;B,1;Q,1];
&nbsp;&nbsp;distance = abs(det(x))/AB;
else
&nbsp;&nbsp;distance = min(AQ,BQ);
end
end

<u>Compute Distance Point To Polygon</u>
Input: a polygon P and a point q.
Output: the distance from q to the closest point in P, called the distance from q to the polygon.

<cite>Using Matlab</cite>
>>function [distance] = d_pp(P,Q)
%P is written as [x1,y1;x2,y2;...] format and Q is written as [x,y] format
n = length(P);
i = 1;
d = [];
while i < n
&nbsp;&nbsp;A = [P(i,1) P(i,2)];
&nbsp;&nbsp;B = [P(i+1,1) P(i+1,2)];
&nbsp;&nbsp;Q = [Q(1,1) Q(1,2)];
&nbsp;&nbsp;AB = norm(A-B);
&nbsp;&nbsp;AQ = norm(A-Q);
&nbsp;&nbsp;BQ = norm(B-Q);
&nbsp;&nbsp;if dot(A-B,Q-B)*dot(B-A,Q-A) >= 0
&nbsp;&nbsp;&nbsp;&nbsp;X = [A,1;B,1;Q,1];
&nbsp;&nbsp;&nbsp;&nbsp;x = sym(X);
&nbsp;&nbsp;&nbsp;&nbsp;distacne = abs(det(x))/AB;
&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;distance = min(AQ,BQ);
&nbsp;&nbsp;end
&nbsp;&nbsp;d(1,i) = distance;
&nbsp;&nbsp;i = i+1:
end
A = [P(1,1) P(1,2)];
B = [P(n,1) P(n,2)];
Q = [Q(1,1) Q(1,2)];
AB = norm(A-B);
AQ = norm(A-Q);
BQ = norm(B-Q);
if dot(A-B,Q-B)*dot(B-A,Q-A) >= 0
&nbsp;&nbsp;X = [A,1;B,1;Q,1];
&nbsp;&nbsp;x = sym(X);
&nbsp;&nbsp;distance = abs(det(x))/AB;
else
&nbsp;&nbsp;distance = min(AQ,BQ);
end
d(1,n) = distance;
distance = min(d);
end

<u>Compute tangent Vector To polygon</u>
Input: a polygon P and a point q.
Output: the unit-length vector u tangent at point q to the polygon P in the following sense: (i) if q is closest to a segment of the polygon, then u should be parallel to the segment, (ii) if q is closest to a vertex, then u should be tangent to a circle centered at the vertex that passes through q, and (iii) the tangent should lie in the counter-clockwise direction. 

<cite>Using Matlab</cite>
>>function [u] = v_pp(P,Q)
n = length(P);
i = 1;
d = [];
%Finding shortest dist from 1->n
while i < n
&nbsp;&nbsp;A = [P(i,1) P(i,2)];
&nbsp;&nbsp;B = [P(i+1,1) P(i+1,2)];
&nbsp;&nbsp;Q = [Q(1,1) Q(1,2)];
&nbsp;&nbsp;AB = norm(A-B);
&nbsp;&nbsp;AQ = norm(A-Q);
&nbsp;&nbsp;BQ = norm(B-Q);
&nbsp;&nbsp;if dot(A-B,Q-B)*dot(B-A,Q-A) >= 0
&nbsp;&nbsp;&nbsp;&nbsp;X = [A,1;B,1;Q,1];
&nbsp;&nbsp;&nbsp;&nbsp;x = sym(X);
&nbsp;&nbsp;&nbsp;&nbsp;distance - abs(det(x))/AB;
&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;distance = min(AQ,BQ);
&nbsp;&nbsp;end
&nbsp;&nbsp;d(1,i) = distance;
&nbsp;&nbsp;i = i+1;
end
%Find dist from n->1
A = [P(1,1) P(1,2)];
B = [P(n,1) P(n,2)];
Q = [Q(1,1) Q(1,2)];
AB = norm(A-B);
AQ = norm(A-Q);
BQ = norm(B-Q);
if dot(A-B,Q-B)*dot(B-A,Q-A) >= 0
&nbsp;&nbsp;X = [A,1;B,1;Q,1];
&nbsp;&nbsp;x = sym(X);
&nbsp;&nbsp;distance = abs(det(x))/AB;
else
&nbsp;&nbsp;distance = min(AQ,BQ);
end
d(1,n) = distance;
distance = min(d);
f = find(ismember(d,distance),1);
if f ==n;
&nbsp;&nbsp;g = 1;
else
&nbsp;&nbsp;g = f+1;
end
x1 = P(f,1)-Q(1,1);
y1 = P(f,2)-Q(1,2);
x2 = P(g,1)-Q(1,1);
y2 = P(g,2)-Q(1,2);
c1 = sqrt(x1^2+y1^2);
c2 = sqrt(x2^2+y2^2);
l1 = sqrt((P(f,1)-P(g,1))^2+(P(f,2)-P(g,2))^2);
if distance ~= c1 & distance ~= c2;
&nbsp;&nbsp;l2 = sqrt(c2^2-distance^2);
&nbsp;&nbsp;xcenter = l2/l1*(x1-x2);
&nbsp;&nbsp;ycenter = l2/l1*(y1-y2);
&nbsp;&nbsp;center = [P(g,1)+xcenter,P(g,2)+ycenter];
&nbsp;&nbsp;x3 = center(1,1)-Q(1,1);
&nbsp;&nbsp;y3 = center(1,2)-Q(1,2);
&nbsp;&nbsp;u = [y3,-x3];
&nbsp;&nbsp;u = u/distance;
elseif c1 < c2
&nbsp;&nbsp;u = [y1,-x1];
&nbsp;&nbsp;u = u/distance;
elseif c2 < c1
&nbsp;&nbsp;u = [y2,-x2];
&nbsp;&nbsp;u = u/distance;
end
%Check if length = 1
%u(1,1)^2+u(1,2)^2
end

**The Bug0 Algorithm**
>>1.**while** not at goal:
2.&nbsp;&nbsp;move towards the goal
3.&nbsp;&nbsp;**if** hit an obstacle:
4.&nbsp;&nbsp;&nbsp;&nbsp;**while** not able to move towards the goal:
5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;follow the obstacle's boundary <cite>moving to the left</cite>

Unfortunately, Bug0 algorithm does not work properly in the sense that there are situations (workspace, obstacles, start and goal positions) for which there exists a solution (a path from start to goal) but the Bug0 algorithm does not find it.

**The Bug1 Algorithm**
>>1.**while** not at goal:
2.&nbsp;&nbsp;move towards the goal
3.&nbsp;&nbsp;**if** hit an obstacle:
4.&nbsp;&nbsp;&nbsp;&nbsp;circumnavigate it(moving to the left or right is unimportant). While circumnavigating, store in memory the minimum distance from the obstacle boundary to the goal
5.&nbsp;&nbsp;&nbsp;&nbsp;follow the boundary back to the boundary point with minimum distance to the goal

**Flowcharts**
* Circles represent the start and terminating poitns
* Arrows indicate the flow of control
* Rectangles represent a single command
* Diamonds output 2 paths based on binary question

<u>Sketch a flowchart and implement the BugBase algorithm.</u>
**The BugBase Algorithm**
**Input**: Two locations start and goal in W, a list of polygon obstacles obstaclesList, and a length step-sizel
**Output**: A sequence, denoted path, of points from start to the first obstacle between start and goal (or from start to goal if no obstacle lies between them). Successive points are separated by no more than step-size.
>>1.current-position = start
2.path = |start|
3.**while** distance(current-position,goal) > step-size:
4.&nbsp;&nbsp;find polygon closest to current-position
5.&nbsp;&nbsp;**if** distance from current-position to closest polygon < step-size:
6.&nbsp;&nbsp;&nbsp;&nbsp;**return** "Failure: There is an obstacle lying between the start and goal" and path
7.&nbsp;&nbsp;&nbsp;&nbsp;compute new current-position by taking a step of length step-size towards goal
8.&nbsp;&nbsp;&nbsp;&nbsp;path = |path,current-position|
9.path = |path,goal|
10.**return** "Success" and path

<img src="/images/ME145/flowchart.jpg">

<u>Compute Bug1</u>
Input: Two locations start and goal in W, a list of polygonal obstacles obstacleList, and a length step-size
Output: A sequence, denoted path, of points from start to goal or returns an error message if such a path does not exists.  Successive points are separted by no more than step-size and are computed accordign to the Bug 1 algorithm.

<cite>Using Matlab</cite>
>>fucntion [path] = Bug_One(S,G,O,Step)
%S = starting point, G = goal point, O = obstacles, Step = Step Size
t = 0;
%Check if solvable or not
i = 1;
l = length (O);
start = [];
goal = [];
while i < l;
&nbsp;&nbsp;[st] = inpolygon(S(1,1),S(1,2),(O{1,i}(:,1)),(O{1,i}(:,2)));
&nbsp;&nbsp;[go] = inpolygon(G(1,1),G(1,2),(O{1,i}(:,1)),(O{1,i}(:,2)));
&nbsp;&nbsp;i = i+1;
&nbsp;&nbsp;start = [start,st];
&nbsp;&nbsp;goal = [goal,go];
end
if sum(start) > 0;
&nbsp;&nbsp;disp('Failure: Start Point in Polygon');
&nbsp;&nbsp;path = Nan;
&nbsp;&nbsp;return;
elseif sum(goal) > 0;
&nbsp;&nbsp;disp('Failure: Goal Point in Polygon');
&nbsp;&nbsp;path = Nan;
&nbsp;&nbsp;return;
else
&nbsp;&nbsp;%Implement Bug 1 Algorithm
&nbsp;&nbsp;current = S;
&nbsp;&nbsp;path = [S];
&nbsp;&nbsp;total = [];
while norm(G-current) > Step;
&nbsp;&nbsp;&nbsp;&nbsp;%Find the Closest polygon to S
&nbsp;&nbsp;&nbsp;&nbsp;j = 1;
&nbsp;&nbsp;&nbsp;&nbsp;Sclosest = [];
&nbsp;&nbsp;&nbsp;&nbsp;while j <= l;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P = O{i,j};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q = S;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[distance] = d_pp(P,Q);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sclosest = [Sclosest,distance];&nbsp;&nbsp;%Matrix dist S to Polygons
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = j+1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t+1;
&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;%Find the Closest Polygon toG
&nbsp;&nbsp;&nbsp;&nbsp;jj = 1;
&nbsp;&nbsp;&nbsp;&nbsp;Gclosest = [];
&nbsp;&nbsp;&nbsp;&nbsp;while jj <=l;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P = O{1,jj};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q = G;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[distance = d_pp(P,Q)];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gclosest = [Gclosest, distance];&nbsp;&nbsp;%Matrix dist G to polygons
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jj = jj+1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t+1;
&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;while sum(Sclosest) < 200;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%Getting Phit

Testing Bug1 Algorithm: start = (0,0) and goal = (5,3) step-size = 0.1 obstacleList = {(1,2),(1,0),(3,0)},{(2,3),(4,1),(5,2)}